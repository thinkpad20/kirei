type Bool = True | False;
type [] a = [] | a :: [a];

// these functions are built-ins
sig && : Bool -> Bool -> Bool;
sig || : Bool -> Bool -> Bool;
sig not : Bool -> Bool;
sig + : Number -> Number -> Number;
sig - : Number -> Number -> Number;
sig * : Number -> Number -> Number;
sig / : Number -> Number -> Number;
sig > : Number -> Number -> Bool;
sig < : Number -> Number -> Bool;
sig >= : Number -> Number -> Bool;
sig <= : Number -> Number -> Bool;
sig == : Number -> Number -> Bool;
sig print : String -> IO -> ();
sig undefined : a;

let ++ list1 list2 = case list1 of
  [] -> list2
| a::as -> a :: (as ++ list2);

let <~ f g = \x -> f (g x);
let ~> f g = \x -> g (f x);

let reverse list =
   let reverse' acc list' = case list' of
     [] -> acc
   | a::as -> reverse' (a::acc) as;
   reverse' [] list;

let lmap f =
  let map acc list = case list of
    [] -> acc
  | x :: xs -> map (f x::acc) xs;
  map [] ~> reverse;

let filter f list =
  let filter' acc list = case list of
    [] -> acc
  | x :: xs -> if f x then filter' (x :: acc) xs else filter' acc xs;
  filter' [] list;

let foldr step start list = case list of
  [] -> start
| a::as -> step a (foldr step start as);

let foldl step start list = case list of
  [] -> start
| a::as -> step (foldl step start as) a;
